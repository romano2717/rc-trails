<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Time Attack Scoring (30/70)</title>

    <style>
      :root {
        --bg: #0b1020;
        --card: #121a33;
        --text: #e9ecf6;
        --muted: #aab2d5;
        --line: #243059;
        --accent: #66e3ff;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial,
          sans-serif;
        background: var(--bg);
        color: var(--text);
      }
      .wrap {
        max-width: 1000px;
        margin: 16px auto;
        padding: 0 14px;
      }
      h1 {
        font-size: clamp(18px, 4vw, 22px);
        margin-bottom: 12px;
      }
      .card {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: 14px;
        padding: 16px;
      }

      label {
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 4px;
        display: block;
      }
      input {
        width: 100%;
        padding: 12px;
        border-radius: 10px;
        border: 1px solid var(--line);
        background: #0e1631;
        color: var(--text);
        font-size: 14px;
      }
      input::placeholder {
        color: #6f7ab0;
      }

      .btn {
        padding: 12px 14px;
        border-radius: 10px;
        border: 1px solid var(--line);
        background: #0e1631;
        color: var(--text);
        cursor: pointer;
        font-size: 14px;
      }
      .btn.primary {
        border: 1px solid transparent;
        background: linear-gradient(#0e1631, #0e1631) padding-box,
          linear-gradient(135deg, var(--accent), #8b5cf6) border-box;
      }
      .btn.danger {
        border: 1px solid transparent;
        background: linear-gradient(#2a0f1a, #2a0f1a) padding-box,
          linear-gradient(135deg, #ff7a7a, #f59e0b) border-box;
      }
      .btn:active {
        transform: translateY(1px);
      }

      .grid {
        display: grid;
        grid-template-columns: 1.4fr 1fr 1fr auto;
        gap: 10px;
      }
      .actions {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        margin-top: 12px;
      }
      .status {
        font-size: 12px;
        color: var(--muted);
        align-self: center;
      }
      .table-wrap {
        margin-top: 14px;
        overflow-x: auto;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        min-width: 760px;
      }
      th,
      td {
        padding: 10px 8px;
        border-bottom: 1px solid var(--line);
        text-align: left;
        white-space: nowrap;
      }
      th {
        font-size: 12px;
        color: var(--muted);
      }
      td {
        font-size: 14px;
      }
      .right {
        text-align: right;
      }
      .rank {
        font-weight: 700;
      }
      .winner {
        color: var(--accent);
      }
      .small {
        font-size: 12px;
        color: var(--muted);
        margin-top: 12px;
        line-height: 1.4;
      }
      code {
        background: #0e1631;
        padding: 2px 6px;
        border-radius: 6px;
        border: 1px solid var(--line);
      }

      @media (max-width: 768px) {
        .grid {
          grid-template-columns: 1fr;
        }
        .btn.primary {
          width: 100%;
        }
        .actions {
          flex-direction: column;
        }
        table {
          min-width: 680px;
        }
      }
    </style>
  </head>

  <body>
    <div class="wrap">
      <h1>
        Time Attack Challenge
        <span style="color: var(--muted); font-size: 12px;"
          >(30% time / 70% deductions)</span
        >
      </h1>

      <div class="card">
        <div class="grid">
          <div>
            <label for="name">Player name</label>
            <input id="name" placeholder="Player 1" />
          </div>
          <div>
            <label for="time">Time (m:ss)</label>
            <input id="time" placeholder="3:15" />
          </div>
          <div>
            <label for="ded">Deductions (0+)</label>
            <input id="ded" type="number" min="0" step="1" placeholder="30" />
          </div>
          <div>
            <label>&nbsp;</label>
            <button class="btn primary" id="addBtn">Add Player</button>
          </div>
        </div>

        <div class="actions">
          <button class="btn" id="computeBtn">Compute Points (and Save)</button>
          <button class="btn" id="clearBtn">Clear Inputs (no delete)</button>
          <button class="btn danger" id="clearTableBtn">
            Clear Table (Delete Saved)
          </button>
          <span class="status" id="status"></span>
        </div>

        <div class="table-wrap">
          <table>
            <thead>
              <tr>
                <th class="right">Rank</th>
                <th>Player</th>
                <th>Time</th>
                <th class="right">Sec</th>
                <th class="right">Deductions</th>
                <th class="right">TimeScore</th>
                <th class="right">DedScore</th>
                <th class="right">Points</th>
                <th class="right">Remove</th>
              </tr>
            </thead>
            <tbody id="tbody"></tbody>
          </table>
        </div>

        <div class="small">
          <code>Points = 100 × (0.30 × TimeScore + 0.70 × DeductionScore)</code
          ><br />
          Tie-breakers: points → lower deductions → faster time
        </div>
      </div>
    </div>

    <script>
      // ---- LocalStorage key ----
      const STORAGE_KEY = "timeAttackPlayers_v1";

      // ---- Utilities ----
      function parseTimeToSeconds(str) {
        const s = (str || "").trim();
        const m = s.match(/^(\d+)\s*:\s*([0-5]?\d)$/);
        if (!m) return null;
        const minutes = Number(m[1]);
        const seconds = Number(m[2]);
        return minutes * 60 + seconds;
      }

      function formatSecondsToTime(totalSeconds) {
        const m = Math.floor(totalSeconds / 60);
        const s = totalSeconds % 60;
        return `${m}:${String(s).padStart(2, "0")}`;
      }

      function clamp01(x) {
        return Math.max(0, Math.min(1, x));
      }
      function round(n, d = 4) {
        const p = 10 ** d;
        return Math.round(n * p) / p;
      }

      function escapeHtml(str) {
        return String(str)
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;");
      }

      // ---- State ----
      const state = { players: [] };

      // ---- DOM ----
      const nameEl = document.getElementById("name");
      const timeEl = document.getElementById("time");
      const dedEl = document.getElementById("ded");
      const addBtn = document.getElementById("addBtn");
      const computeBtn = document.getElementById("computeBtn");
      const clearBtn = document.getElementById("clearBtn");
      const clearTableBtn = document.getElementById("clearTableBtn");
      const tbody = document.getElementById("tbody");
      const statusEl = document.getElementById("status");

      function setStatus(msg) {
        statusEl.textContent = msg || "";
      }

      // ---- Persistence ----
      function saveToStorage() {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state.players));
      }

      function loadFromStorage() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return false;
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) return false;
          state.players = parsed;
          return true;
        } catch {
          return false;
        }
      }

      function clearStorage() {
        localStorage.removeItem(STORAGE_KEY);
      }

      // ---- Rendering ----
      function render() {
        tbody.innerHTML = "";

        if (state.players.length === 0) {
          const tr = document.createElement("tr");
          tr.innerHTML = `<td colspan="9" style="color:var(--muted)">No players yet. Add players, then compute.</td>`;
          tbody.appendChild(tr);
          return;
        }

        state.players.forEach((p) => {
          const tr = document.createElement("tr");
          const rank = p.rank ?? "";
          const rankClass =
            rank === 1 || rank === 2 || rank === 3 ? "rank winner" : "rank";

          tr.innerHTML = `
        <td class="right ${rankClass}">${rank}</td>
        <td>${escapeHtml(p.name)}</td>
        <td>${escapeHtml(p.timeStr)}</td>
        <td class="right">${p.timeSec ?? ""}</td>
        <td class="right">${p.deductions ?? ""}</td>
        <td class="right">${
          p.timeScore != null ? round(p.timeScore, 4) : ""
        }</td>
        <td class="right">${p.dedScore != null ? round(p.dedScore, 4) : ""}</td>
        <td class="right">${p.points != null ? round(p.points, 2) : ""}</td>
        <td class="right"><button class="btn" data-remove="${
          p.id
        }">X</button></td>
      `;
          tbody.appendChild(tr);
        });

        // remove handlers
        tbody.querySelectorAll("button[data-remove]").forEach((btn) => {
          btn.addEventListener("click", () => {
            const id = btn.getAttribute("data-remove");
            state.players = state.players.filter((p) => p.id !== id);
            compute(false); // recompute (no forced save here; compute() will save)
          });
        });
      }

      // ---- Core computation (and optional save) ----
      function compute(showStatus = true) {
        // Reset computed fields
        state.players.forEach((p) => {
          p.timeScore = null;
          p.dedScore = null;
          p.points = null;
          p.rank = null;
        });

        if (state.players.length < 2) {
          if (showStatus)
            setStatus("Add at least 2 players to compute rankings.");
          render();
          // still save so you don't lose entered data
          saveToStorage();
          return;
        }

        const times = state.players.map((p) => p.timeSec);
        const deds = state.players.map((p) => p.deductions);

        const Tmin = Math.min(...times);
        const Tmax = Math.max(...times);
        const Dmin = Math.min(...deds);
        const Dmax = Math.max(...deds);

        const timeDen = Tmax - Tmin;
        const dedDen = Dmax - Dmin;

        state.players.forEach((p) => {
          const timeScore = timeDen === 0 ? 1 : (Tmax - p.timeSec) / timeDen;
          const dedScore = dedDen === 0 ? 1 : (Dmax - p.deductions) / dedDen;

          p.timeScore = clamp01(timeScore);
          p.dedScore = clamp01(dedScore);
          p.points = 100 * (0.3 * p.timeScore + 0.7 * p.dedScore);
        });

        // Sort with tie-breakers: points desc, deductions asc, time asc
        const sorted = [...state.players].sort((a, b) => {
          if (b.points !== a.points) return b.points - a.points;
          if (a.deductions !== b.deductions) return a.deductions - b.deductions;
          return a.timeSec - b.timeSec;
        });

        sorted.forEach((p, i) => {
          p.rank = i + 1;
        });
        state.players = sorted;

        if (showStatus)
          setStatus(
            `Computed & saved. Tmin=${Tmin}s, Tmax=${Tmax}s, Dmin=${Dmin}, Dmax=${Dmax}.`
          );

        render();
        saveToStorage(); // ✅ SAVE ON COMPUTE (and after removals)
      }

      // ---- Add player ----
      function addPlayer() {
        const name = (nameEl.value || "").trim();
        const timeStr = (timeEl.value || "").trim();
        const dedStr = (dedEl.value || "").trim();

        if (!name) return setStatus("Player name is required.");
        const timeSec = parseTimeToSeconds(timeStr);
        if (timeSec == null)
          return setStatus("Time must be in m:ss (e.g., 3:15).");

        const deductions = Number(dedStr);
        if (!Number.isFinite(deductions) || deductions < 0)
          return setStatus("Deductions must be 0 or more.");

        state.players.push({
          id: crypto.randomUUID
            ? crypto.randomUUID()
            : String(Date.now() + Math.random()),
          name,
          timeStr: formatSecondsToTime(timeSec),
          timeSec,
          deductions: Math.round(deductions),
          timeScore: null,
          dedScore: null,
          points: null,
          rank: null,
        });

        nameEl.value = "";
        timeEl.value = "";
        dedEl.value = "";

        setStatus("Player added. Click Compute Points to calculate + save.");
        render();
        // Not saving on add by request — saving happens on Compute.
      }

      // ---- Wire up ----
      addBtn.addEventListener("click", addPlayer);
      computeBtn.addEventListener("click", () => compute(true));

      clearBtn.addEventListener("click", () => {
        nameEl.value = "";
        timeEl.value = "";
        dedEl.value = "";
        setStatus("Inputs cleared.");
      });

      clearTableBtn.addEventListener("click", () => {
        state.players = [];
        clearStorage();
        setStatus("Table cleared and saved data deleted.");
        render();
      });

      // Enter key to add
      [nameEl, timeEl, dedEl].forEach((el) => {
        el.addEventListener("keydown", (e) => {
          if (e.key === "Enter") addPlayer();
        });
      });

      // ---- On load: restore saved data and show it ----
      const restored = loadFromStorage();
      render();
      if (restored && state.players.length > 0) {
        // Recompute on load so ranks/points are consistent with formula
        compute(false);
        setStatus("Loaded saved data.");
      } else {
        setStatus("Ready.");
      }
    </script>
  </body>
</html>
